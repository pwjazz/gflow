// Copyright 2011 Percy Wegmann. All rights reserved.
// Use of this source code is governed by the BSD license found in LICENSE.

/**
 * This package provides a mechanism for defining and processing event-driven flows.
 * Such a flow accepts events one at a time and advances the flow depending on
 * whether or not the event meets the required conditions.
 *
 *
 * Let a, b, c ... equal a set of conditions for advancing a flow
 * Let A, B, C ... equal a set of events that meet the corresponding conditions
 *
 * A flow can be composed of these conditions using the operators THEN, OR and AND
 *
 * For example, given the flow defined as:
 *
 * a.THEN(
 *   a.THEN(b).OR(
 *      c.THEN(d.AND(e)))
 * )
 *
 * Any of the following series of events will complete the flow:
 *
 * A -> C -> B
 * A -> C -> D
 * A -> A -> C -> B
 * A -> A -> C -> D -> E
 * A -> A -> C -> E -> DA
 *
 * Because each event can only advance the flow by 1 step, the following would not complete the flow:
 *
 * A -> B -> C (the A is NOT double-counted)
 *
 * Given an action "action", a flow can be configured to fire that action upon completion using the DO operator
 * 
 * For example, given:
 *
 * a.THEN(b).DO(action)
 *
 * action will fire immediately after the sequence
 *
 * A -> B
 *
 */
package gflow

/* TYPES */

/**
 * A function that tests against the given ProcessData and returns a bool indicating whether or not the flow is allowed to transition
 */
type Test func(data ProcessData) bool

type Action func(data ProcessData)

// Data that is passed through the process flow to test and action functions
type ProcessData map[string]string

type transition struct {
    test Test
    from *State
    to   *State
}

type State struct {
    in          []*transition
    out         []*transition
    andedStates []*State
    action      Action
}

type StateSource interface {
    state() *State
}

/* FUNCTIONS */
func (state *State) state() *State {
    return state
}

func (test Test) state() *State {
    from := new(State)
    to := new(State)
    trans := &transition{test: test, from: from, to: to}
    to.addIn(trans)
    from.addOut(trans)
    return to
}

func (state *State) addIn(trans *transition) {
    trans.to = state
    state.in = append(state.in, trans)
}

func (state *State) addOut(trans *transition) {
    trans.from = state
    state.out = append(state.out, trans)
}

func (state *State) root() *State {
    if len(state.in) == 0 {
        return state
    }
    return state.in[0].from.root()
}

func (state *State) copy() *State {
    stateCopies := make(map[*State]*State)

    state.root().doCopy(stateCopies)

    return stateCopies[state]
}

func (state *State) doCopy(stateCopies map[*State]*State) *State {
    stateCopy := stateCopies[state]
    if stateCopy == nil {
        stateCopy = new(State)
        stateCopies[state] = stateCopy
    }

    for _, out := range state.out {
        newTo := out.to.doCopy(stateCopies)
        trans := &transition{test: out.test, from: stateCopy, to: newTo}
        stateCopy.addOut(trans)
        newTo.addIn(trans)
    }

    for _, andedState := range state.andedStates {
        stateCopy.andedStates = append(stateCopy.andedStates, stateCopies[andedState])
    }

    stateCopy.action = state.action
    return stateCopy
}

func (from *State) THEN(to StateSource) *State {
    toState := to.state()
    root := toState.root()
    for _, trans := range root.out {
        from.addOut(trans)
    }
    return toState
}

func (from Test) THEN(to StateSource) *State {
    return from.state().THEN(to)
}

func (state *State) OR(other StateSource) *State {
    otherState := other.state()
    // Create a common start node
    start := new(State)
    // Create a common end node
    end := new(State)

    root := state.root()
    otherRoot := otherState.root()

    start.addOrStates(root, otherRoot, end)
    return end
}

func (state *State) addOrStates(left *State, right *State, end *State) {
    for _, trans := range left.out {
        atEnd := len(trans.to.out) == 0
        var next *State
        if atEnd {
            next = end
        } else {
            next = new(State)
        }
        newTrans := &transition{test: trans.test, from: state, to: next}
        state.addOut(newTrans)
        next.addIn(newTrans)
        if !atEnd {
            next.addOrStates(trans.to, right, end)
        }
    }
    for _, trans := range right.out {
        atEnd := len(trans.to.out) == 0
        var next *State
        if atEnd {
            next = end
        } else {
            next = new(State)
        }
        newTrans := &transition{test: trans.test, from: state, to: next}
        state.addOut(newTrans)
        next.addIn(newTrans)
        if !atEnd {
            next.addOrStates(left, trans.to, end)
        }
    }
}

func (test Test) OR(other StateSource) *State {
    return test.state().OR(other)
}

func (state *State) AND(other StateSource) *State {
    otherState := other.state()
    // Create a common start node
    start := new(State)
    // Create a common end node
    end := new(State)

    andedStates := state.andedStates
    if len(andedStates) == 0 {
        andedStates = append(andedStates, state)
    }
    andedStates = append(andedStates, otherState)
    end.andedStates = andedStates
     
    andedRoots := make([]*State, len(andedStates))
    for i, state := range andedStates {
        andedRoots[i] = state.root()
    }
    
    start.addAndStates(andedRoots, end)
    
    return end
}

func replace(states []*State, index int, state *State) []*State {
    var result []*State
    result = append(result, states[0:index]...)
    result = append(result, state)
    result = append(result, states[index+1:len(states)]...)
    return result
}

func remove(states []*State, index int) []*State {
    var result []*State
    result = append(result, states[0:index]...)
    result = append(result, states[index+1:len(states)]...)
    return result
}

func (state *State) addAndStates(andedStates []*State, end *State) {
    atEnd := true
    totalOuts := 0
    for _, andedState := range andedStates {
        totalOuts += len(andedState.out)
    }
    for i, andedState := range andedStates {
        for _, trans := range andedState.out {
            atEnd = false
            next := new(State)
            newTrans := &transition{test: trans.test, from: state, to: next}
            state.addOut(newTrans)
            next.addIn(newTrans)
            var nextAndedStates []*State
            nextAndedStates = replace(andedStates, i, trans.to)
            next.addAndStates(nextAndedStates, end)
        }
    }
    if atEnd {
        for _, trans := range state.in {
            // Switch the transition to terminate at the end state
            end.addIn(trans)
        }
    }
}

func (test Test) AND(other StateSource) *State {
    return test.state().AND(other)
}

func (state *State) DO(action Action) *State {
    state.action = action
    return state
}

func (state *State) Start(data ProcessData) *State {
    root := state.root().copy()
    return root.Advance(data)
}

func (state *State) Advance(data ProcessData) *State {
    // Go through outbound transitions and see which pass the test
    for _, tran := range state.out {
        if tran.test(data) {
            // Transition test passed, advance
            if tran.to.action != nil {
                // We've reached our action and the flow is done
                tran.to.action(data)
                return nil
            }
            // Advance to the next State
            return tran.to
        }
    }
    return state
}

func permutations(items []*State) [][]*State {
    var result [][]*State
    result = append(result, rotate(items, 2)...)
    return result
}

func rotate(items []*State, depth int) [][]*State {
    var result [][]*State
    numberOfItems := len(items)
    if depth > numberOfItems {
        result = append(result, items)
        return result
    }
    for i := numberOfItems - depth; i < numberOfItems; i++ {
        current := items[i:]
        current = append(current, items[:i]...)
        result = append(result, rotate(current, depth+1)...)
    }
    return result
}