/**
 * This package provides a mechanism for defining and processing event-driven flows.
 * Such a flow accepts events one at a time and advances the flow depending on
 * whether or not the event meets the required conditions.
 *
 *
 * Let a, b, c ... equal a set of conditions for advancing a flow
 * Let A, B, C ... equal a set of events that meet the corresponding conditions
 *
 * A flow can be composed of these conditions using the operators THEN, OR, AND
 *
 * For example, given the flow defined as:
 *
 * a.THEN(
 *   a.THEN(b).OR(
 *   c.THEN(d))
 * )
 *
 * Any of the following series of events will complete the flow:
 *
 * a -> a -> b
 * a -> c -> d
 * a -> a -> c -> b
 * a -> a -> c -> d
 *
 * Because each event can only advance the flow by 1 step, the following would not complete the flow:
 *
 * a -> b -> c (the a is NOT double-counted)
 *
 * Given an action "action", a flow can be configured to fire that action upon completion using the DO operator
 * 
 * For example:
 *
 * a.THEN(a.THEN(b).OR(c.THEN(d)).DO(action)
 *
 */
package main

import (
	"fmt"
)

var currentId int = 0

func nextId() int {
	currentId += 1
	return currentId
}

type ProcessData map[string]string

type Test func(data ProcessData) bool

type Action func(data ProcessData)

type transition struct {
	test Test
	from *State
	to   *State
}

type State struct {
	in          []*transition
	out         []*transition
	andedStates []*State
	action      Action
}

type StateSource interface {
	state() *State
}

func (state *State) state() *State {
	return state
}

func (test Test) state() *State {
	from := new(State)
	to := new(State)
	trans := &transition{test: test, from: from, to: to}
	to.addIn(trans)
	from.addOut(trans)
	return to
}

func (state *State) addIn(trans *transition) {
	trans.to = state
	state.in = append(state.in, trans)
}

func (state *State) addOut(trans *transition) {
	trans.from = state
	state.out = append(state.out, trans)
}

func (state *State) root() *State {
	if len(state.in) == 0 {
		return state
	}
	return state.in[0].from.root()
}

func (state *State) copy() *State {
	stateCopies := make(map[*State]*State)

	state.root().doCopy(stateCopies)

	return stateCopies[state]
}

func (state *State) doCopy(stateCopies map[*State]*State) *State {
	stateCopy := stateCopies[state]
	if stateCopy == nil {
		stateCopy = new(State)
		stateCopies[state] = stateCopy
	}

	for _, out := range state.out {
		newTo := out.to.doCopy(stateCopies)
		trans := &transition{test: out.test, from: stateCopy, to: newTo}
		stateCopy.addOut(trans)
		newTo.addIn(trans)
	}

	for _, andedState := range state.andedStates {
		stateCopy.andedStates = append(stateCopy.andedStates, stateCopies[andedState])
	}

	stateCopy.action = state.action
	return stateCopy
}

func (from *State) THEN(to StateSource) *State {
	toState := to.state()
	root := toState.root()
	for _, trans := range root.out {
		from.addOut(trans)
	}
	return toState
}

func (from Test) THEN(to StateSource) *State {
	return from.state().THEN(to)
}

func (state *State) OR(other StateSource) *State {
	otherState := other.state()
	// Create new end node that combines all inbound transitions from the two OR'd states
	result := new(State)
	fmt.Println("state.in", len(state.in))
	for _, trans := range state.in {
		result.addIn(trans)
	}
	fmt.Println("otherState.in", len(otherState.in))
	for _, trans := range otherState.in {
		result.addIn(trans)
	}
	// Create a common root that combines the out transitions from the two OR'd states' roots
	root := new(State)
	fmt.Println("state.root.out", len(state.root().out))
	for _, trans := range state.root().out {
		root.addOut(trans)
	}
	fmt.Println("otherState.root.out", len(otherState.root().out))
	for _, trans := range otherState.root().out {
		root.addOut(trans)
	}
	fmt.Println("result", len(result.in), len(root.out), len(result.root().out))
	return result
}

func (test Test) OR(other StateSource) *State {
	return test.state().OR(other)
}

func (state *State) AND(other StateSource) *State {
	andedStates := state.root().andedStates
	if len(andedStates) == 0 {
		andedStates = append(andedStates, state)
	}
	andedStates = append(andedStates, other.state())

	allPermutations := permutations(andedStates)

	var endState *State

	for i, states := range allPermutations {
		var newState *State

		for j, state := range states {
			if j == 0 {
				newState = state.copy()
			} else {
				newState = newState.THEN(state.copy())
			}
		}

		if i == 0 {
			endState = newState
		} else {
			endState = endState.OR(newState)
		}
	}

	fmt.Println("End state", len(endState.root().out), len(endState.in))
	return endState
}

func (test Test) AND(other StateSource) *State {
	return test.state().AND(other)
}

func (state *State) DO(action Action) *State {
	state.action = action
	return state
}

func (state *State) start(data ProcessData) *State {
	root := state.root().copy()
	return root.advance(data)
}

func (state *State) advance(data ProcessData) *State {
	// Build a new state
	result := new(State)
	// Add inbound transitions from original state
	for _, tran2 := range state.in {
		result.addIn(&transition{test: tran2.test, from: tran2.from, to: result})
	}
	// Go through outbound transitions and see which pass the test
	for _, tran := range state.out {
		if tran.test(data) {
			// Transition test passed, advance
			if tran.to.action != nil {
				// We've reached our action and the flow is done
				tran.to.action(data)
				return nil
			}
			if len(state.out) == 1 {
				// Since there's only 1 transition, we can advance to the next state
				return tran.to
			} else {
				// There are other transitions, so just add the outbound transitions of the next state to our result
				for _, tran3 := range tran.to.out {
					result.addOut(&transition{test: tran3.test, from: result, to: tran3.to})
				}
			}
		} else {
			result.addOut(tran)
		}
	}
	return result
}

func permutations(items []*State) [][]*State {
	var result [][]*State
	result = append(result, rotate(items, 2)...)
	return result
}

func rotate(items []*State, depth int) [][]*State {
	var result [][]*State
	numberOfItems := len(items)
	if depth > numberOfItems {
		result = append(result, items)
		return result
	}
	for i := numberOfItems - depth; i < numberOfItems; i++ {
		current := items[i:]
		current = append(current, items[:i]...)
		result = append(result, rotate(current, depth+1)...)
	}
	return result
}

func main() {
	var a Test = func(data ProcessData) bool {
		fmt.Println("A?", data)
		return "A" == data["key"]
	}
	var b Test = func(data ProcessData) bool {
		fmt.Println("B?", data)
		return "B" == data["key"]
	}
	var c Test = func(data ProcessData) bool {
		fmt.Println("C?", data)
		return "C" == data["key"]
	}
	var d Test = func(data ProcessData) bool {
		fmt.Println("D?", data)
		return "D" == data["key"]
	}
	var result = func(data ProcessData) {
		fmt.Println("Done!")
	}

	flow := a.THEN(b).THEN(c.THEN(d)).DO(result)

	var advance = func(order []string) {
		fmt.Println("testing", order)
		flow = flow.start(ProcessData{"key": order[0]})
		for idx, key := range order {
			if idx > 0 && flow != nil {
				flow = flow.advance(ProcessData{"key": key})
			}
		}
	}

	advance([]string{"A", "B", "C", "D"})

	flow = a.THEN(b).THEN(c).THEN(d).DO(result)
	advance([]string{"A", "B", "C", "D"})

	flow = a.THEN(b).THEN(c.THEN(d)).DO(result)
	advance([]string{"A", "B", "C", "D"})

	/*
	  flow = a.THEN(b).OR(c.THEN(d)).DO(result)
	  advance([]string{"A", "C", "B", "D"})
	*/
	flow = a.THEN(b).OR(c.THEN(d)).DO(result)
	advance([]string{"A", "C", "D"})
	/*
	  flow = a.THEN(b).OR(c.THEN(d)).DO(result)
	  advance([]string{"A", "C", "B"})*/

	flow = a.AND(b).AND(c.AND(d)).DO(result)
	advance([]string{"B", "A", "F", "C", "G", "D"})

	flow = a.OR(b).AND(c.OR(d)).DO(result)
	advance([]string{"B", "A", "D", "C", "B", "D"})

	flow = a.THEN(b).AND(c).DO(result)
	advance([]string{"B", "D", "A", "C", "B", "D"})

	/*
		flow = a.AND(b).AND(c).DO(result)
		advance([]string{"B", "A", "F", "C"})
	*/
	fmt.Println("end")
}
