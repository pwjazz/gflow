   Package gflow provides a mechanism for defining and processing
   event-driven flows.

   Such a flow accepts events one at a time and advances the flow depending on
   whether or not the event meets the required conditions.

   Let a, b, c ... equal a set of conditions for advancing a flow
   Let A, B, C ... equal a set of events that meet the relevant conditions

   A flow can be composed of these conditions using the operators

   THEN OR AND

   For example, given the flow defined as:

   a.THEN(a).THEN(b)
    .OR(c.AND(d))

   Any of the following series of events will complete the flow:

   A -> A -> B
   C -> D
   D -> C

   Because each event can only advance the flow by 1 step, the following would not complete the flow:

   A -> B (the A is NOT double-counted)

   Given an action "action", a flow can be configured to fire that action
   upon completion using the DO operator.

   For example, given:

   a.THEN(b).DO(action)

   action will fire immediately after the sequence:

   A -> B

   Whether or not a given transition is allowed is encapsulated by a Test,
   which is just a function like this:

   var a gflow.Test = func(data gflow.ProcessData) bool {
       return // Test data and return a bool
   }

   Flows are defined by composing Tests using the aforementioned operators:

   flowDefinition := a.THEN(a).THEN(b).OR(c.AND(d))

   Event data is passed around flows in the form of a ProcessData,
   which is just a map[string]string:

   eventA := gflow.ProcessData{key: val, anotherKey: anotherVal}

   To start a flow, simply call the function Start and pass it a ProcessData
   for the first event:

   flow = flowDefinition.Start(eventA)

   Start returns a state representing the result of evaluating the event.
   This will be either the original state if we did not advance 
   or a new state if we did advance. 

   IMPORTANT: once constructed, a flow is immutable and thread-safe.
   
   To continue advancing through a flow starting at the last state,
   use the method Advance:

   flow = flow.Advance(eventB)

   Just liks Start, Advance returns a state.

   To tell whether or not a flow is finished, use the method Finished:

   isFinished = flow.Finished()

   Once a flow is finished, it is legal to keep sending events to it,
   but this will have no effect.
   
   Since the flows are stateless, it is up to the client code to track
   the current state of the flow by hanging on to the return value
   from each call to Start() and Advance().